\section{Co-occurence based multimodal recommender}
\label{sec:design}
\tikzset{
  reco/.style={
    rectangle
  },
}

\begin{figure}
  \centering
  \begin{tikzpicture}[->, >=latex]
    \node[reco] (rec) at(180:3cm) {Recommender};
    \node (hist) at(60:3cm){History};
    \node (se) at(300:3cm){Search engine};
    \node (user) [left of=rec,node distance=5cm]{User};
    \node(x)[align=left] at(130:3.9cm){lookup\\ user's history};
    \node(x)[align=left] at(0:2cm){user's\\ history};
    \node(x)[align=left] at(220:4cm){ranked \\ search result};
    \draw[->, >=latex] (170:3cm) arc  (170:80:3cm);
    \draw[->, >=latex] (40:3cm)  arc (40:-40:3cm);
   \draw[->, >=latex] (270:3cm)  arc (270:190:3cm);
   \draw[->, >=latex] (40:3cm)  arc (40:-40:3cm);
   \path (user) edge[bend left=40] node[anchor=south,above]{request top-N list}(rec);
   \path (rec) edge[bend left=40] node[anchor=north,below]{top-N list}(user);
  \end{tikzpicture}
  \caption{Simplified dataflow diagram}
  \label{fig:topndataflow}
\end{figure}

The recommender we discuss will use past user behavior and metadata of items to compute the similarity between all items. Hence it is a hybrid recommender.
We use user \gls{coocc} of user- and tag-iteminteractions as a similarity metric among items.

Because search engine are a way of finding similar documents according to a query we can use a search engine to find similar items to the ones the user already exressed some interest.

The process of procucing a \gls{topn} can be divided into five steps. Figure \ref{fig:topndataflow} illustrates this process.

\begin{enumerate}
\item User requests a \gls{topn}.
\item The recommenders looks up items that appear in the recent user history.
\item The user's action history the recommender is send as a query to the search engine.
\item The search engine returns a ranked search result set of items according to the query.
\item The recommender removes item already known to the user and present him a \gls{topn}.
\end{enumerate}

The section first describes the used input data. Than we explain the process of computing \gls{topn} and how similarity between items is measured and how the computation is implemented. Next we describe the similarities of the top-N recommender task and a \gls{rankedretrieval} and how we extend the scoring function of the search engine in order to use \gls{coocc} similaty metric.

\input{inputdata}
\input{topnmath}
\input{similarity}

\subsection{Using more than one type of behavior}
\label{sec:multimodal}

Most collaborative filtering algorithms use only explicit or implicit ratings to compute similarity.
But we can improve the performance of the recommender engine by using multiple types of user actions. In addition to likes we could use tag-associations to compute the similariy. In table \ref{tbl:llr} we count co-occurence of items in a user's like-action history. Instead of the action history we could use tags that are associated width items. We count the co-occurence of each items associated with a tag.

Suppose we compute a \gls{indicatorm} based on likes $M_l$ and one based on tag associations $M_t$. An $h_l$ is a user's history of ``likes'' and $h_t$ is the user's tag history. Then we can compute the recommendation vector (see equation \ref{eq:recommendation}) $r$ with

\begin{equation}
  \label{eq:multi}
  r = h_l M_l + h_t M_t
\end{equation}

In our demo web application we use ``likes'' and tags but virtually all user actions can be used to improve the recommendation.

\input{searchengine}

\subsection{Integration}
\label{sec:integration}

The recommender discussed in this report has to parts.
\begin{description}
\item[Analysing User Input (offline)] In this part the user action are analised in order to compute the similarities of items. The similiarities are stored as indicators.
\item[Generate personalized recommendations (online)] A systems formats a list of recommended items.
\end{description}


\subsubsection{Retrieve recommendation}

In order to produce recommendations we compose a Solr query from the user history. The user history is stored in the web log. The web server sends this query to Solr. Solr responds with a ranked result set. The web server then formats the response from Solr and sends a list of recommended items to the user.

\begin{figure}
\centering
\begin{tikzpicture}[node distance=20mm,
data/.style={
rectangle,
draw,
thin,
minimum height=3.5em
},
to/.style={->,>=stealth',shorten >=1pt,semithick,font=\footnotesize},]

\node (web) [data] {Web server};
\node (log) [data,below of = web, align=left] {User actions\\log file};
\node (browser) [data,left of=web,node distance=50mm] {Webbrowser};
\node (solr) [data,right of=web,node distance=50mm] {Search engine};
\draw[to] (web) -- (log);
\draw[to] (browser) -- node[midway,above] {user actions} (web);
\end{tikzpicture}
\caption{The web server sends this query to Solr. Solr responds with a ranked result set.}
\end{figure}

\verb|updatesearchengine| will index all movies in Solr.

Solr is used in the offline and the online part of the recommendation engine.

The items and their corresponding similarity indicators from the Apache Spark job are stored with Apache Solr. 

We store all items as documents in Solr. The documents contain the metadata like (title, genre, tags, etc). In addidtion we populate a filed for every indicator with the similar item ID's discovered with the coocuccence similartiy from section \ref{sec:llr}.

In order to build a recommender using a search engine we store the output of the co-occurence analysis in Solr. The search engine actually delivers the recommendations to our users.

\subsection{Parameters}
\label{sec:parameters}

This section descripes the paratemter of the recommender discussed in this report.
\begin{description}
\item[similarity threshold] We have to define a threshold to separate similar items occording to the LLR similarity from the rest (e.g. 0.5).
\item[user history to consider] We retrieve recommendations with a part of the user history. We have to define the number of log entries to consider.
\end{description}

\subsection{Two-parts design}

The recommender described in this article is divided in two parts.
\begin{itemize}
\item Computation of simililarity and the update of the text search engine is done offline, ahead of time.
\item Recommendations are generated instantly by quering the text search engine using rescents actions of the user.
\end{itemize}
