\section{Introduction}
\label{sec:intro}

Recommender engines have become very common in recent years. They help consumers or users of a platform to discover unknown article or items by suggesting them a list of items that are likely to be appealing to them. 
For instance, they help users of a on-demand movie provider to find movies they might like. Without a recommender the user would have to choose among 100000 titles manually. Because it is not possible for a user to look at every movie separtly in order to decide if he likes it the provider infers the users preferences and present him a list of movies he might like. This list is referred as \gls{topn}. If a user has purchased the movies "Terminator 2" and "Transformers" the recommender engine will present the act him a list of other similar action movies (e.g. Matrix, Iron Man).
E-commerce sites that deploy a recommender engine can have a increase in sales of 8 - 13 percent \footnote{http://www.practicalecommerce.com/articles/1942-10-Questions-on-Product-Recommendations}.

\subsection{Recommender strategies}
\label{sec:strategies}

There are different strategies to recommend a user new items \cite{jannach11}.
\begin{description}
\item[Collaborative Filtering] This strategy is only based on past user behavior. Such behavior include explicit user ratings or other user activities like purchases, likes and click. For example, a recommender engine based on collaborativ filtering uses the ratings of all users to compute the similarity between all items. 
It requires no domain knowledge. Recommender engines based on collaborative filtering do not care what the items are and what attributes they have. This can be an advantage because the same technique can be applied to different domains and different types of items. 

User preferences will change over time. Another advandage is that collaborative filtering will update the model automaticaly as it's exposed to new user histories. The systems learns.

There are several categories of collaborative filtering algorithms:
\begin{description}
\item[Non-personalized] Non-personalized recommender engines suggest all users the same \gls{topn}. For instance, a non-personalized recommender presents all users an ordered list of items. Items with the largest number of ratings are shown first.
\item[Neighborhood based] Neighborhood models are based on the similartiy among users and items. For instance, two items are similar because they have similar ratings of the same users. In order to predict a unknown preference for an item $i$ the recommender computes the nearest neigbors of $i$ and considers the users past ratings for the similar items. This approach was used by Amazon.com according to \cite{Linden}. Neighorhood models can be further divided by their similarity metric (e.g. cosine, log-likelihood ratio).
\item[Latent factor approach] Latent factor approaches model users and items as vectors. The rating of a user on an item is predicted by computing the inner product between the related latent factor vectors. The recommender problem is reduced to the optimization problem of finding the best vectors.
\end{description}
\item[Content based filterting] Content-based recommendation techniques use attributes of the items in order to predict preferences of users. For example, a movie can be described by \glspl{tag}. A user profile indicates the type of items a user likes. These algorithms recommend items that are similar to the user profile. The profile could be built from users past actions.
\end{description}

\todo{diagram mit aufteilung machen}

The recommender presented in this report is a combination of collaborative filtering and content-based filtering. In order to compute similarities among items its uses both; past user actions and \glspl{tag} associated with items. 

\subsection{Why is it difficult to build a recommender engine?}

There are several challenges in building a recommender engine.

\begin{itemize}
\item When dealing with huge datasets, the calculation of the similarties or the latent factor vector is computationaly expensive. Either a large amount of computation power is necessary or the compution of a \gls{topn} takes too long.
\item Many algorithms relies on explicit user ratings. User invited to rate items on a scale from 1 to 5. Only a small subset of users rate a small subset of items. This leads to very few ratings that and these ratings represents only users who like to rate.
\item According to  \cite{Dunning14} the process of designing an advanced and accurate recommender engine requires a team of highly trained engineer and data scientist. The process requires to try a huge collection of algorithms at each problem and selecting the algoritm that gives the best result. This is too expensive for small companies. An alternative is to use products with drag-and-drop approaches. These products automaticaly select the right algorithms. They aren't very accurate and a the user has to spend most of the time putting the data into the right format.
\end{itemize}

\subsection{The design goals a practical recommender}
\label{sec:practical}

In order make the development of a recommender engine easier and cost-effective \cite{Dunning14} proposes a simplified, practical approach that provides profitable results and facilitate the processing of large-scale datesets. 

The described recommender does not predict a rating value. It suggests the user a list of items that are likely to be of interest to him. This list is called a \gls{topn}.

The design proposed by \cite{Dunning14} has the following goals:
\begin{itemize}
\item A small-scale development teams can build a recommender engine.
\item To build the model use algorithms that can be computed at scale with distributed computation framework, such as Apache Hadoop or Apache Spark. We compute \gls{coocc} with Apache Spark. The system is \gls{scalable} for big data.
\item Use the search capabilities of a existing search engine, such as Apache Solr, to produce the \gls{topn}. The search engine indexes items represented as documents instead of text documents. The fields of these documents indicate similarity to other items indicators The query is composed of the users past actions that we want to recommend. The depoyment of a search engine saves development costs. In addition it is easier to scale the system. Producing a \gls{topn} with an neighborhood based collaborative filtering algorithm is similar to process a document query in a text retrieval system. 
\item The top-N recommender task should be fast.
\item The recommender engine takes user behavior instead of explicit user ratingsas input. Because only a small subset of users are willing to rate items and user behavior is the best clue to what they want the input data should be collected user behavior, like clicking or purchasing. User behavior interaction are only associations between a user and an item and there is no notion of strength represented as number. This associations are Boolean preferences. It exist or it doesn't exist. 
\item Several types (e.g. clicks, views, purchases) of user actions are used to improve recommendations and it is possible to extend the recommender with additional \glspl{indicator}. Many existing collaborativ filtering algorithms use only one user activity to model preference \cite{ferrel}. In addition metadata, like tags, are used to improve the accuracy. The recommender combines collaborative filtering and content-based filtering(hybrid approach). A recommender that uses a variety of user activities is called a \gls{multimodal} recommender. 
\end{itemize}

There are academic approaches that produce recommendations with a smaller error but these require complex mathematical models. The focus of this approach is not to minimize the error but to make the development and deployment of a recommender more approachable.

\subsection{Two-parts design}

The recommender described in this article is divided in two parts.
\begin{itemize}
\item Computation of simililarity and the update of the text search engine is done offline, ahead of time.
\item Recommendations are generated instantly by quering the text search engine using rescents actions of the user.

\end{itemize}

\subsection{Overview}

Section \ref{sec:design} will describe the design of the co-occurence based recommender. The similiarity metric log-likelihood ratio is described and a short introduction for the search engine Apache Solr is given.

Section \ref{sec:design} will describe how different type of interactions is used as input data to train the recommender.

In section \ref{sec:evaluation} we evaluate the accuracy of the co-occurence recommender. We describe the performance metrics \gls{precision} and \gls{recall} (section \ref{sec:precision}). Then we describe the evaluation methodology (section \ref{sec:methodology}). We compare the performance of the \gls{coocc} recommender to several baseline algorithms (section \ref{sec:baseline}). As a evaluation test set use the rating and tag activity of the MovieLens data set (section \ref{sec:dataset}). In section \ref{sec:results} we present the results.